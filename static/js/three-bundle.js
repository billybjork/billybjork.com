// Auto-generated by esbuild - do not edit directly

"use strict";(()=>{var ct=Object.create;var we=Object.defineProperty;var ht=Object.getOwnPropertyDescriptor;var ut=Object.getOwnPropertyNames;var mt=Object.getPrototypeOf,pt=Object.prototype.hasOwnProperty;var W=(t=>typeof require<"u"?require:typeof Proxy<"u"?new Proxy(t,{get:(e,o)=>(typeof require<"u"?require:e)[o]}):t)(function(t){if(typeof require<"u")return require.apply(this,arguments);throw Error('Dynamic require of "'+t+'" is not supported')});var ft=(t,e,o,i)=>{if(e&&typeof e=="object"||typeof e=="function")for(let r of ut(e))!pt.call(t,r)&&r!==o&&we(t,r,{get:()=>e[r],enumerable:!(i=ht(e,r))||i.enumerable});return t};var q=(t,e,o)=>(o=t!=null?ct(mt(t)):{},ft(e||!t||!t.__esModule?we(o,"default",{value:t,enumerable:!0}):o,t));var G=q(W("three"),1);var X=(i=>(i[i.Soft=0]="Soft",i[i.Circle=1]="Circle",i[i.Square=2]="Square",i))(X||{}),$=(r=>(r[r.Original=0]="Original",r[r.Depth=1]="Depth",r[r.Normal=2]="Normal",r[r.Blend=3]="Blend",r))($||{});var j="/static/test/rgbd-sprites",T="640x360",Te=80,Ce=45,_=50,A=100,Me=1,Re=.25,ye=.15,re=.96,M=180,K=100,De=120,Ae=140,Le=900,Pe=.35,ne={pointDensity:.5,pointSize:2,depthAmount:25,tiltRange:20,mouseParallax:12,depthAmountCenter:8,edgeScatterCenter:0,opacityEdge:.85,transitionCurve:.6,pointShape:0,sizeAttenuation:!0,depthSizing:1.2,opacity:1,depthOpacity:!1,edgeScatter:.8,edgeThreshold:.15,dofEnable:!1,dofFocal:.5,dofStrength:1,colorMode:0,showDepth:!1,showEdges:!1,showDensity:!1},gt={depthAmount:25,tiltRange:20,meshSegments:150,edgeThreshold:.15,edgeSoftness:2,edgeAwareExtrusion:!1,edgeFade:!1,normalShading:!1,showDepth:!1,showEdges:!1,showNormals:!1},vt={tiltRange:0,mouseParallax:0,edgeScatter:0,edgeScatterCenter:0,opacityEdge:1};function Z(t){return{...ne,...t}}function Q(t){return{...gt,...t}}function ae(t,e){return e?{...t,...vt,depthAmount:t.depthAmountCenter}:t}function Ue(t){return t.replace(/-([a-z])/g,(e,o)=>o.toUpperCase())}function He(t){return{soft:0,circle:1,square:2}[t]??0}function _e(t){return{original:0,depth:1,normal:2,blend:3}[t]??0}var b=q(W("three"),1);var z=class{renderer;scene;camera;renderState={width:0,height:0,renderedCount:0};constructor(e){this.renderer=new b.WebGLRenderer({canvas:e,antialias:!0,alpha:!0,powerPreference:"high-performance"}),this.renderer.setPixelRatio(Math.min(window.devicePixelRatio,2)),this.renderer.setClearColor(0,0),this.renderer.autoClear=!1,this.scene=new b.Scene,this.camera=new b.PerspectiveCamera(_,1,.1,2e3),this.camera.position.set(0,0,A),this.camera.lookAt(0,0,0),this.resize()}getRenderState(){return{...this.renderState}}getRenderedCount(){return this.renderState.renderedCount}resize(){let e=window.innerWidth,o=window.innerHeight,i=Math.min(window.devicePixelRatio,2);(this.renderState.width!==e||this.renderState.height!==o||this.renderer.getPixelRatio()!==i)&&(this.renderState.width=e,this.renderState.height=o,this.renderer.setPixelRatio(i),this.renderer.setSize(e,o,!1),this.camera.aspect=e/Math.max(o,1),this.camera.updateProjectionMatrix())}render(e,o,i){this.resize();let r=this.renderer;if(r.setScissorTest(!1),r.setViewport(0,0,this.renderState.width,this.renderState.height),r.clear(!0,!0,!0),this.camera.updateMatrixWorld(!0),e.length===0){this.renderState.renderedCount=0;return}e.forEach(({thumb:a,rect:s})=>{a.setVisible(!0),a.update(o,i,s)}),r.render(this.scene,this.camera),this.renderState.renderedCount=e.length}dispose(){for(;this.scene.children.length>0;){let e=this.scene.children[0];e&&this.scene.remove(e)}typeof this.renderer.forceContextLoss=="function"&&this.renderer.forceContextLoss(),this.renderer.dispose()}};function se(){let t=document.createElement("canvas");return!!(t.getContext("webgl2")||t.getContext("webgl"))}var L=new Map;function Et(t,e,o){let i=Math.max(1,Math.round(1/o));return`${t}x${e}@${i}`}function bt(t,e,o){let i=Math.max(1,Math.round(1/o)),r=Math.ceil(t/i),a=Math.ceil(e/i),s=r*a,d=new Float32Array(s*2),l=0;for(let h=0;h<a;h++)for(let E=0;E<r;E++)d[l++]=(E*i+i/2)/t,d[l++]=(h*i+i/2)/e;let n=new b.BufferGeometry;n.setAttribute("pixelUV",new b.BufferAttribute(d,2));let u=new Float32Array(s*3);return n.setAttribute("position",new b.BufferAttribute(u,3)),n}function ze(t,e,o){let i=Et(t,e,o),r=L.get(i);return r||(r={geometry:bt(t,e,o),refs:0},L.set(i,r)),r.refs+=1,{key:i,geometry:r.geometry}}function Ve(t){if(!t)return;let e=L.get(t);e&&(e.refs-=1,e.refs<=0&&(e.geometry.dispose(),L.delete(t)))}function le(){L.forEach(t=>{t.geometry.dispose()}),L.clear()}var m=q(W("three"),1);var Oe=`
    uniform sampler2D depthAtlas;
    uniform sampler2D rgbAtlas;
    uniform float frameIndex;
    uniform vec2 atlasSize;
    uniform vec2 frameSize;
    uniform float columns;
    uniform float depthAmount;
    uniform float pointSize;
    uniform float depthSizing;
    uniform float attenuationBase;
    uniform bool sizeAttenuation;
    uniform float edgeScatter;
    uniform float edgeThreshold;
    uniform float time;

    attribute vec2 pixelUV;

    varying vec2 vUv;
    varying float vDepth;
    varying float vEdgeMask;
    varying vec3 vNormal;
    varying vec3 vColor;

    float hash(vec2 p) {
        return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453);
    }

    vec2 getAtlasUV(vec2 localUV, float frame) {
        vec2 clampedUV = clamp(localUV, vec2(0.001), vec2(0.999));
        float col = mod(frame, columns);
        float row = floor(frame / columns);
        vec2 flippedLocalUV = vec2(clampedUV.x, 1.0 - clampedUV.y);
        vec2 frameOffset = vec2(col * frameSize.x, row * frameSize.y);
        return (frameOffset + flippedLocalUV * frameSize) / atlasSize;
    }

    float sampleDepth(vec2 localUV) {
        vec2 depthUV = getAtlasUV(localUV, frameIndex);
        return texture2D(depthAtlas, depthUV).r;
    }

    vec3 sampleColor(vec2 localUV) {
        return texture2D(rgbAtlas, getAtlasUV(localUV, frameIndex)).rgb;
    }

    void main() {
        vUv = pixelUV;

        float depth = sampleDepth(pixelUV);
        vDepth = depth;
        vColor = sampleColor(pixelUV);

        vec2 texelSize = 1.0 / frameSize;
        float depthL = sampleDepth(pixelUV + vec2(-texelSize.x, 0.0));
        float depthR = sampleDepth(pixelUV + vec2(texelSize.x, 0.0));
        float depthU = sampleDepth(pixelUV + vec2(0.0, -texelSize.y));
        float depthD = sampleDepth(pixelUV + vec2(0.0, texelSize.y));

        float gradX = (depthR - depthL) * 0.5;
        float gradY = (depthD - depthU) * 0.5;
        float gradMag = sqrt(gradX * gradX + gradY * gradY);

        vEdgeMask = 1.0 - smoothstep(edgeThreshold * 0.5, edgeThreshold, gradMag);
        vNormal = normalize(vec3(-gradX * 10.0, -gradY * 10.0, 1.0));

        float planeWidth = 80.0;
        float planeHeight = 45.0;
        vec3 pos;
        pos.x = (pixelUV.x - 0.5) * planeWidth;
        pos.y = (pixelUV.y - 0.5) * planeHeight;
        pos.z = depth * depthAmount;

        if (edgeScatter > 0.0) {
            float frameSeed = frameIndex;
            float edgeFactor = 1.0 - vEdgeMask;
            float noiseX = hash(pixelUV + frameSeed * 0.1) * 2.0 - 1.0;
            float noiseY = hash(pixelUV.yx + frameSeed * 0.1 + 100.0) * 2.0 - 1.0;
            float noiseZ = hash(pixelUV * 2.0 + frameSeed * 0.1 + 200.0) * 2.0 - 1.0;

            float scatterAmount = edgeFactor * edgeScatter;
            pos.x += noiseX * scatterAmount * 3.0;
            pos.y += noiseY * scatterAmount * 2.0;
            pos.z += noiseZ * scatterAmount * depthAmount * 0.3;
        }

        vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);
        gl_Position = projectionMatrix * mvPosition;

        float size = pointSize;
        size *= mix(1.0, depthSizing, depth);
        if (sizeAttenuation) {
            size *= (300.0 / -mvPosition.z) * attenuationBase;
        }

        gl_PointSize = size;
    }
`,Ie=`
    uniform float opacity;
    uniform bool depthOpacity;
    uniform int pointShape; // 0 = soft, 1 = circle, 2 = square
    uniform int colorMode; // 0 = original, 1 = depth, 2 = normal, 3 = blend
    uniform bool showDepth;
    uniform bool showEdges;
    uniform bool showDensity;
    uniform bool dofEnable;
    uniform float dofFocal;
    uniform float dofStrength;

    varying vec2 vUv;
    varying float vDepth;
    varying float vEdgeMask;
    varying vec3 vNormal;
    varying vec3 vColor;

    // Viridis-like colormap for depth visualization
    vec3 viridis(float t) {
        const vec3 c0 = vec3(0.267, 0.004, 0.329);
        const vec3 c1 = vec3(0.282, 0.140, 0.457);
        const vec3 c2 = vec3(0.253, 0.265, 0.529);
        const vec3 c3 = vec3(0.191, 0.407, 0.556);
        const vec3 c4 = vec3(0.127, 0.566, 0.550);
        const vec3 c5 = vec3(0.267, 0.678, 0.480);
        const vec3 c6 = vec3(0.478, 0.761, 0.363);
        const vec3 c7 = vec3(0.741, 0.843, 0.215);
        const vec3 c8 = vec3(0.993, 0.906, 0.144);

        t = clamp(t, 0.0, 1.0);
        float idx = t * 7.0;
        int i = int(floor(idx));
        float f = fract(idx);

        if (i == 0) return mix(c0, c1, f);
        if (i == 1) return mix(c1, c2, f);
        if (i == 2) return mix(c2, c3, f);
        if (i == 3) return mix(c3, c4, f);
        if (i == 4) return mix(c4, c5, f);
        if (i == 5) return mix(c5, c6, f);
        if (i == 6) return mix(c6, c7, f);
        return mix(c7, c8, f);
    }

    void main() {
        vec2 pc = gl_PointCoord - 0.5;
        float dist = length(pc);

        // Point shape
        float alpha = 1.0;
        if (pointShape == 0) {
            // Soft/Gaussian falloff
            alpha = exp(-dist * dist * 8.0);
        } else if (pointShape == 1) {
            // Circle - hard edge
            if (dist > 0.5) discard;
        }
        // pointShape == 2 is square, no modification needed

        // Debug views
        if (showDepth) {
            gl_FragColor = vec4(vec3(vDepth), alpha * opacity);
            return;
        }

        if (showEdges) {
            float edge = 1.0 - vEdgeMask;
            gl_FragColor = vec4(edge, edge * 0.5, 0.0, alpha * opacity);
            return;
        }

        if (showDensity) {
            // Visualize as grid pattern
            vec2 grid = fract(vUv * 20.0);
            float g = step(0.1, grid.x) * step(0.1, grid.y);
            gl_FragColor = vec4(vec3(g * 0.5 + 0.5), alpha * opacity);
            return;
        }

        // Color modes
        vec3 color;
        if (colorMode == 0) {
            // Original RGB
            color = vColor;
        } else if (colorMode == 1) {
            // Depth colorized
            color = viridis(vDepth);
        } else if (colorMode == 2) {
            // Normal colorized
            color = vNormal * 0.5 + 0.5;
        } else {
            // Blend - mix original with depth color
            color = mix(vColor, viridis(vDepth), 0.3);
        }

        // Opacity adjustments
        float finalOpacity = opacity * alpha;

        // Depth-based opacity (fade distant points)
        if (depthOpacity) {
            finalOpacity *= mix(0.3, 1.0, vDepth);
        }

        // Depth of field effect
        if (dofEnable) {
            float dofDist = abs(vDepth - dofFocal);
            float blur = dofDist * dofStrength;
            // Simulate bokeh by making out-of-focus points larger but more transparent
            finalOpacity *= 1.0 / (1.0 + blur * 2.0);
        }

        gl_FragColor = vec4(color, finalOpacity);
    }
`,de=`
    uniform sampler2D depthAtlas;
    uniform float frameIndex;
    uniform vec2 atlasSize;
    uniform vec2 frameSize;
    uniform float columns;
    uniform float extrusionAmount;
    uniform float edgeThreshold;
    uniform bool edgeAwareExtrusion;

    varying vec2 vUv;
    varying float vDepth;
    varying float vEdgeMask;
    varying vec3 vNormal;

    vec2 getAtlasUV(vec2 localUV, float frame) {
        float col = mod(frame, columns);
        float row = floor(frame / columns);
        vec2 flippedLocalUV = vec2(localUV.x, 1.0 - localUV.y);
        vec2 frameOffset = vec2(col * frameSize.x, row * frameSize.y);
        return (frameOffset + flippedLocalUV * frameSize) / atlasSize;
    }

    float sampleDepth(vec2 localUV) {
        vec2 depthUV = getAtlasUV(localUV, frameIndex);
        return texture2D(depthAtlas, depthUV).r;
    }

    void main() {
        vUv = uv;

        // Sample depth at this vertex
        float depth = sampleDepth(uv);
        vDepth = depth;

        // Calculate depth gradient using neighboring samples
        vec2 texelSize = 1.0 / frameSize;
        float depthL = sampleDepth(uv + vec2(-texelSize.x, 0.0));
        float depthR = sampleDepth(uv + vec2(texelSize.x, 0.0));
        float depthU = sampleDepth(uv + vec2(0.0, -texelSize.y));
        float depthD = sampleDepth(uv + vec2(0.0, texelSize.y));

        // Gradient magnitude (Sobel-like)
        float gradX = (depthR - depthL) * 0.5;
        float gradY = (depthD - depthU) * 0.5;
        float gradMag = sqrt(gradX * gradX + gradY * gradY);

        // Edge mask: 1 = smooth area, 0 = edge
        vEdgeMask = 1.0 - smoothstep(edgeThreshold * 0.5, edgeThreshold, gradMag);

        // Reconstruct normal from depth gradient
        vNormal = normalize(vec3(-gradX * 10.0, -gradY * 10.0, 1.0));

        // Calculate extrusion (optionally reduced at edges)
        float extrusion = depth * extrusionAmount;
        if (edgeAwareExtrusion) {
            extrusion *= vEdgeMask;
        }

        vec3 displaced = position;
        displaced.z = extrusion;

        gl_Position = projectionMatrix * modelViewMatrix * vec4(displaced, 1.0);
    }
`,Fe=`
    uniform sampler2D rgbAtlas;
    uniform sampler2D depthAtlas;
    uniform float frameIndex;
    uniform vec2 atlasSize;
    uniform vec2 frameSize;
    uniform float columns;
    uniform float edgeThreshold;
    uniform float edgeSoftness;
    uniform bool edgeFade;
    uniform bool normalShading;
    uniform bool showDepth;
    uniform bool showEdges;
    uniform bool showNormals;
    uniform vec3 lightDir;

    varying vec2 vUv;
    varying float vDepth;
    varying float vEdgeMask;
    varying vec3 vNormal;

    vec2 getAtlasUV(vec2 localUV, float frame) {
        float col = mod(frame, columns);
        float row = floor(frame / columns);
        vec2 flippedLocalUV = vec2(localUV.x, 1.0 - localUV.y);
        vec2 frameOffset = vec2(col * frameSize.x, row * frameSize.y);
        return (frameOffset + flippedLocalUV * frameSize) / atlasSize;
    }

    void main() {
        vec2 rgbUV = getAtlasUV(vUv, frameIndex);
        vec4 color = texture2D(rgbAtlas, rgbUV);

        // Recalculate edge in fragment for smoother result
        vec2 texelSize = 1.0 / frameSize;
        vec2 depthUV = getAtlasUV(vUv, frameIndex);

        float depthC = texture2D(depthAtlas, depthUV).r;
        float depthL = texture2D(depthAtlas, getAtlasUV(vUv + vec2(-texelSize.x, 0.0), frameIndex)).r;
        float depthR = texture2D(depthAtlas, getAtlasUV(vUv + vec2(texelSize.x, 0.0), frameIndex)).r;
        float depthU = texture2D(depthAtlas, getAtlasUV(vUv + vec2(0.0, -texelSize.y), frameIndex)).r;
        float depthD = texture2D(depthAtlas, getAtlasUV(vUv + vec2(0.0, texelSize.y), frameIndex)).r;

        float gradX = (depthR - depthL) * 0.5;
        float gradY = (depthD - depthU) * 0.5;
        float gradMag = sqrt(gradX * gradX + gradY * gradY);

        // Edge mask with softness control
        float edgeMask = 1.0 - smoothstep(edgeThreshold * 0.5, edgeThreshold * edgeSoftness, gradMag);

        // Reconstruct normal
        vec3 normal = normalize(vec3(-gradX * 10.0, -gradY * 10.0, 1.0));

        // Debug views
        if (showDepth) {
            gl_FragColor = vec4(vec3(depthC), 1.0);
            return;
        }

        if (showEdges) {
            float edge = 1.0 - edgeMask;
            gl_FragColor = vec4(edge, edge * 0.5, 0.0, 1.0);
            return;
        }

        if (showNormals) {
            gl_FragColor = vec4(normal * 0.5 + 0.5, 1.0);
            return;
        }

        // Apply edge fade (darken edges)
        if (edgeFade) {
            color.rgb *= mix(0.3, 1.0, edgeMask);
        }

        // Apply normal-based shading
        if (normalShading) {
            float diffuse = max(dot(normal, lightDir), 0.0);
            diffuse = mix(0.5, 1.0, diffuse);

            float rim = 1.0 - max(dot(normal, vec3(0.0, 0.0, 1.0)), 0.0);
            rim = pow(rim, 2.0) * 0.3;

            color.rgb *= diffuse;
            color.rgb += rim * vec3(0.4, 0.5, 0.6);
        }

        gl_FragColor = color;
    }
`,Ne=`
    varying float vEdgeMask;

    void main() {
        // Color wireframe by edge detection
        vec3 color = mix(vec3(1.0, 0.3, 0.0), vec3(0.0, 1.0, 0.0), vEdgeMask);
        gl_FragColor = vec4(color, 0.5);
    }
`;var V=class{container;spriteId;currentTilt=0;currentPanX=0;currentPanY=0;viewportPosition=.5;pointCount=0;currentCoherence;isRenderable=!1;isInViewportMargin=!0;cachedRect=null;sharedRenderer;spriteSets;config;resolution;prefersReducedMotion;geometryKey=null;lastDebugUpdateMs=0;lastLayoutWidth=-1;lastLayoutHeight=-1;lastLayoutLeft=Number.NaN;lastLayoutTop=Number.NaN;lastLayoutCanvasWidth=-1;lastLayoutCanvasHeight=-1;debugElements=null;group;motionGroup;points=null;material=null;virtualCamera;virtualLookTarget;constructor(e,o,i,r,a,s=T,d=!1){this.container=e,this.spriteId=o,this.sharedRenderer=i,this.spriteSets=r,this.config=Z(a),this.resolution=s,this.prefersReducedMotion=d,this.currentCoherence=d?1:0;let l=this.container.querySelector(".thumbnail-debug");l&&(this.debugElements={tiltAngle:l.querySelector(".tilt-angle"),frameNum:l.querySelector(".frame-num"),frameTotal:l.querySelector(".frame-total"),coherenceVal:l.querySelector(".coherence-val")}),this.group=new m.Group,this.group.visible=!1,this.motionGroup=new m.Group,this.motionGroup.matrixAutoUpdate=!1,this.group.add(this.motionGroup),i.scene.add(this.group),this.virtualCamera=new m.PerspectiveCamera(_,1,.1,2e3),this.virtualLookTarget=new m.Vector3}get spriteData(){return this.spriteSets[this.spriteId]}get metadata(){return this.spriteData?.metadata}updateConfig(e){this.config={...this.config,...e}}setReducedMotion(e){this.prefersReducedMotion=e,this.currentCoherence=e?1:this.currentCoherence}createPointCloud(){let e=this.spriteData;if(!e)return;let{metadata:o,rgbTexture:i,depthTexture:r}=e,a=o.resolutions[this.resolution];if(!a)return;let s=ze(a.frame_width,a.frame_height,this.config.pointDensity);this.geometryKey=s.key;let d=s.geometry;this.pointCount=d.getAttribute("pixelUV").count,this.material=new m.ShaderMaterial({vertexShader:Oe,fragmentShader:Ie,uniforms:{rgbAtlas:{value:i},depthAtlas:{value:r},frameIndex:{value:0},atlasSize:{value:new m.Vector2(a.sheet_width,a.sheet_height)},frameSize:{value:new m.Vector2(a.frame_width,a.frame_height)},columns:{value:o.columns},depthAmount:{value:this.config.depthAmount},pointSize:{value:this.config.pointSize},depthSizing:{value:this.config.depthSizing},attenuationBase:{value:A/100},sizeAttenuation:{value:this.config.sizeAttenuation},edgeScatter:{value:this.config.edgeScatter},edgeThreshold:{value:this.config.edgeThreshold},time:{value:0},opacity:{value:this.config.opacity},depthOpacity:{value:this.config.depthOpacity},pointShape:{value:this.config.pointShape},colorMode:{value:this.config.colorMode},showDepth:{value:this.config.showDepth},showEdges:{value:this.config.showEdges},showDensity:{value:this.config.showDensity},dofEnable:{value:this.config.dofEnable},dofFocal:{value:this.config.dofFocal},dofStrength:{value:this.config.dofStrength}},transparent:!0,depthWrite:!1,blending:m.NormalBlending}),this.points=new m.Points(d,this.material),this.points.frustumCulled=!1,this.motionGroup.add(this.points),this.debugElements?.frameTotal&&(this.debugElements.frameTotal.textContent=String(o.frames))}rebuildPointCloud(){this.disposePointCloud(),this.createPointCloud()}disposePointCloud(){this.points&&(this.motionGroup.remove(this.points),this.points=null),this.material&&(this.material.dispose(),this.material=null),this.geometryKey&&(Ve(this.geometryKey),this.geometryKey=null)}destroy(){this.disposePointCloud(),this.group&&this.sharedRenderer?.scene&&this.sharedRenderer.scene.remove(this.group)}updateViewportPosition(e){let o=window.innerHeight,i=e.top+e.height/2;this.viewportPosition=1-i/o,this.viewportPosition=Math.max(-.2,Math.min(1.2,this.viewportPosition))}setVisible(e){this.group&&(this.group.visible=e)}syncLayout(e){if(!this.group)return;let o=this.sharedRenderer.getRenderState(),i=Math.floor(e.left),r=Math.floor(e.top),a=Math.max(1,Math.ceil(e.width)),s=Math.max(1,Math.ceil(e.height));if(this.lastLayoutWidth===a&&this.lastLayoutHeight===s&&this.lastLayoutLeft===i&&this.lastLayoutTop===r&&this.lastLayoutCanvasWidth===o.width&&this.lastLayoutCanvasHeight===o.height)return;this.lastLayoutWidth=a,this.lastLayoutHeight=s,this.lastLayoutLeft=i,this.lastLayoutTop=r,this.lastLayoutCanvasWidth=o.width,this.lastLayoutCanvasHeight=o.height;let d=m.MathUtils.degToRad(_*.5),l=2*A*Math.tan(d),n=o.height/Math.max(l,1e-6),u=(i+a/2-o.width/2)/n,h=(o.height/2-(r+s/2))/n,E=a*re/(Te*n),k=s*re/(Ce*n),ie=(E+k)*.5;this.group.position.set(u,h,0),this.group.scale.set(E,k,ie)}updateMotionTransform(e){if(!this.motionGroup||!this.sharedRenderer?.camera)return;let o=this.sharedRenderer.camera;Math.abs(this.virtualCamera.aspect-o.aspect)>1e-6&&(this.virtualCamera.aspect=o.aspect,this.virtualCamera.updateProjectionMatrix());let i=m.MathUtils.degToRad(this.currentTilt),r=A,a=Math.sin(i)*r*Me,s=this.currentPanY*Re;this.virtualCamera.position.x=this.currentPanX,this.virtualCamera.position.y=a+s,this.virtualCamera.position.z=Math.cos(i)*r,this.virtualLookTarget.set(this.currentPanX*.3,this.currentPanY*ye,e/2),this.virtualCamera.lookAt(this.virtualLookTarget),this.virtualCamera.updateMatrixWorld(!0),this.motionGroup.matrix.copy(this.sharedRenderer.camera.matrixWorld).multiply(this.virtualCamera.matrixWorldInverse),this.motionGroup.matrixWorldNeedsUpdate=!0}update(e,o,i,r=0,a=0,s=!1,d=0,l=0){if(!this.material||!this.metadata)return;let n=this.config,u=this.metadata,h=Math.floor(e)%u.frames;h<0&&(h+=u.frames),this.updateViewportPosition(i);let E=Math.abs((this.viewportPosition-.5)*2),k=Math.min(1,Math.max(0,E)),ie=Math.pow(k,n.transitionCurve),tt=this.prefersReducedMotion?1:1-ie,ot=this.prefersReducedMotion?1:.1;this.currentCoherence+=(tt-this.currentCoherence)*ot;let ve=n.depthAmountCenter+(n.depthAmount-n.depthAmountCenter)*(1-this.currentCoherence),it=n.edgeScatterCenter+(n.edgeScatter-n.edgeScatterCenter)*(1-this.currentCoherence),rt=n.opacityEdge+(n.opacity-n.opacityEdge)*this.currentCoherence,nt=(this.viewportPosition-.5)*2*n.tiltRange,Ee=r,be=-a;s&&(Ee=d,be=l);let at=Ee*n.mouseParallax,st=be*n.mouseParallax*.6,lt=nt,dt=this.prefersReducedMotion?1:.12,Se=this.prefersReducedMotion?1:.15;this.currentTilt+=(lt-this.currentTilt)*dt,this.currentPanX+=(at-this.currentPanX)*Se,this.currentPanY+=(st-this.currentPanY)*Se;let p=this.material.uniforms;p.frameIndex.value=h,p.depthAmount.value=ve,p.pointSize.value=n.pointSize,p.depthSizing.value=n.depthSizing,p.sizeAttenuation.value=n.sizeAttenuation,p.edgeScatter.value=it,p.edgeThreshold.value=n.edgeThreshold,p.time.value=o,p.opacity.value=rt,p.depthOpacity.value=n.depthOpacity,p.pointShape.value=n.pointShape,p.colorMode.value=n.colorMode,p.showDepth.value=n.showDepth,p.showEdges.value=n.showEdges,p.showDensity.value=n.showDensity,p.dofEnable.value=n.dofEnable,p.dofFocal.value=n.dofFocal,p.dofStrength.value=n.dofStrength,this.syncLayout(i),this.updateMotionTransform(ve);let xe=performance.now();xe-this.lastDebugUpdateMs>=K&&(this.debugElements?.tiltAngle&&(this.debugElements.tiltAngle.textContent=this.currentTilt.toFixed(1)+"\xB0"),this.debugElements?.frameNum&&(this.debugElements.frameNum.textContent=String(h+1)),this.debugElements?.coherenceVal&&(this.debugElements.coherenceVal.textContent=Math.round(this.currentCoherence*100)+"%"),this.lastDebugUpdateMs=xe)}};var c=q(W("three"),1);var O=class{canvas;container;spriteId;currentTilt=0;viewportPosition=.5;spriteSets;config;resolution;showWireframe=!1;scene;renderer;camera;mesh=null;wireframeMesh=null;material=null;wireframeMaterial=null;debugElements=null;constructor(e,o,i,r,a=T){this.canvas=e,this.container=e.parentElement,this.spriteId=o,this.spriteSets=i,this.config=Q(r),this.resolution=a;let s=this.container.querySelector(".thumbnail-debug");s&&(this.debugElements={tiltAngle:s.querySelector(".tilt-angle"),frameNum:s.querySelector(".frame-num"),frameTotal:s.querySelector(".frame-total")}),this.scene=new c.Scene,this.scene.background=new c.Color(0),this.renderer=new c.WebGLRenderer({canvas:e,antialias:!0}),this.renderer.setPixelRatio(Math.min(window.devicePixelRatio,2));let d=this.container.clientWidth/this.container.clientHeight;this.camera=new c.PerspectiveCamera(50,d,.1,1e3),this.camera.position.set(0,0,100),this.updateSize()}get spriteData(){return this.spriteSets[this.spriteId]}get metadata(){return this.spriteData?.metadata}updateConfig(e){this.config={...this.config,...e}}setWireframe(e){this.showWireframe=e}createMesh(){let e=this.spriteData;if(!e)return;let{metadata:o,rgbTexture:i,depthTexture:r}=e,a=o.resolutions[this.resolution];if(!a)return;let s=a.frame_width/a.frame_height,d=this.config.meshSegments,l=Math.round(d/s),n=80,u=n/s,h=new c.PlaneGeometry(n,u,d,l);this.material=new c.ShaderMaterial({vertexShader:de,fragmentShader:Fe,uniforms:{rgbAtlas:{value:i},depthAtlas:{value:r},frameIndex:{value:0},atlasSize:{value:new c.Vector2(a.sheet_width,a.sheet_height)},frameSize:{value:new c.Vector2(a.frame_width,a.frame_height)},columns:{value:o.columns},extrusionAmount:{value:this.config.depthAmount},edgeThreshold:{value:this.config.edgeThreshold},edgeSoftness:{value:this.config.edgeSoftness},edgeAwareExtrusion:{value:this.config.edgeAwareExtrusion},edgeFade:{value:this.config.edgeFade},normalShading:{value:this.config.normalShading},lightDir:{value:new c.Vector3(.3,.5,1).normalize()},showDepth:{value:this.config.showDepth},showEdges:{value:this.config.showEdges},showNormals:{value:this.config.showNormals}},side:c.DoubleSide}),this.mesh=new c.Mesh(h,this.material),this.scene.add(this.mesh),this.wireframeMaterial=new c.ShaderMaterial({vertexShader:de,fragmentShader:Ne,uniforms:{depthAtlas:{value:r},frameIndex:{value:0},atlasSize:{value:new c.Vector2(a.sheet_width,a.sheet_height)},frameSize:{value:new c.Vector2(a.frame_width,a.frame_height)},columns:{value:o.columns},extrusionAmount:{value:this.config.depthAmount},edgeThreshold:{value:this.config.edgeThreshold},edgeAwareExtrusion:{value:this.config.edgeAwareExtrusion}},wireframe:!0,transparent:!0,depthTest:!1}),this.wireframeMesh=new c.Mesh(h.clone(),this.wireframeMaterial),this.wireframeMesh.visible=!1,this.scene.add(this.wireframeMesh),this.debugElements?.frameTotal&&(this.debugElements.frameTotal.textContent=String(o.frames))}updateViewportPosition(){let e=this.container.getBoundingClientRect(),o=window.innerHeight,i=e.top+e.height/2;this.viewportPosition=1-i/o,this.viewportPosition=Math.max(-.2,Math.min(1.2,this.viewportPosition))}update(e){if(!this.material||!this.metadata)return;let o=this.config,i=this.metadata,r=Math.floor(e)%i.frames;r<0&&(r+=i.frames),this.updateViewportPosition();let a=(this.viewportPosition-.5)*2*o.tiltRange;this.currentTilt+=(a-this.currentTilt)*.12;let s=this.material.uniforms;if(s.frameIndex.value=r,s.extrusionAmount.value=o.depthAmount,s.edgeThreshold.value=o.edgeThreshold,s.edgeSoftness.value=o.edgeSoftness,s.edgeAwareExtrusion.value=o.edgeAwareExtrusion,s.edgeFade.value=o.edgeFade,s.normalShading.value=o.normalShading,s.showDepth.value=o.showDepth,s.showEdges.value=o.showEdges,s.showNormals.value=o.showNormals,this.wireframeMaterial){let n=this.wireframeMaterial.uniforms;n.frameIndex.value=r,n.extrusionAmount.value=o.depthAmount,n.edgeThreshold.value=o.edgeThreshold,n.edgeAwareExtrusion.value=o.edgeAwareExtrusion}this.wireframeMesh&&(this.wireframeMesh.visible=this.showWireframe);let d=c.MathUtils.degToRad(this.currentTilt),l=100;this.camera.position.y=Math.sin(d)*l*.5,this.camera.position.z=Math.cos(d)*l,this.camera.lookAt(0,0,o.depthAmount/2),this.debugElements?.tiltAngle&&(this.debugElements.tiltAngle.textContent=this.currentTilt.toFixed(1)+"\xB0"),this.debugElements?.frameNum&&(this.debugElements.frameNum.textContent=String(r+1)),this.renderer.render(this.scene,this.camera)}updateSize(){let e=this.container.clientWidth,o=this.container.clientHeight;this.renderer.setSize(e,o),this.camera.aspect=e/o,this.camera.updateProjectionMatrix()}dispose(){this.mesh&&(this.scene.remove(this.mesh),this.mesh.geometry.dispose(),this.mesh=null),this.wireframeMesh&&(this.scene.remove(this.wireframeMesh),this.wireframeMesh.geometry.dispose(),this.wireframeMesh=null),this.material&&(this.material.dispose(),this.material=null),this.wireframeMaterial&&(this.wireframeMaterial.dispose(),this.wireframeMaterial=null),this.renderer.dispose()}};var x={},ce=[],g=[],R=[],v=null,S={...ne},he=!0,Y=!1,I=null,P=null,J=null,U=null,y=0,f=0,F=0,ee=Date.now(),St=Date.now()+Le,ue=Date.now(),H=!0,Ge=0,D=null,me=0,pe=0,qe=0,Xe=0,$e=!1,fe=window.matchMedia("(prefers-reduced-motion: reduce)"),te=fe.matches,N=null,oe=new Map;function C(t,e,o,i){t.addEventListener(e,o,i),ce.push({target:t,type:e,handler:o,options:i})}function xt(){ce.forEach(({target:t,type:e,handler:o,options:i})=>{t.removeEventListener(e,o,i)}),ce.length=0}async function Ye(t,e){return new Promise((o,i)=>{t.load(e,o,void 0,i)})}async function je(t,e=j){let o=`${e}/${t}`,i;try{i=await(await fetch(`${o}/metadata.json`)).json()}catch(l){return console.error(`Failed to load metadata for ${t}:`,l),null}let r=new G.TextureLoader,a=i.resolutions[T];if(!a)return console.error(`Resolution ${T} not found for ${t}`),null;let[s,d]=await Promise.all([Ye(r,`${o}/${a.rgb_file}`),Ye(r,`${o}/${a.depth_file}`)]);return[s,d].forEach(l=>{l.minFilter=G.LinearFilter,l.magFilter=G.LinearFilter,l.generateMipmaps=!1,l.flipY=!1}),console.log(`Loaded sprite set: ${t} (${i.frames} frames)`),{metadata:i,rgbTexture:s,depthTexture:d}}function Be(t){te=t,t?(S=ae(S,!0),f=0):S=ae(S,!1),g.forEach(e=>{e.setReducedMotion(t),e.updateConfig(S)})}function wt(){C(window,"mousemove",t=>{me=t.clientX/window.innerWidth*2-1,pe=t.clientY/window.innerHeight*2-1},{passive:!0}),C(window,"mouseleave",()=>{me=0,pe=0},{passive:!0})}function ke(){C(window,"deviceorientation",t=>{t.gamma!==null&&t.beta!==null&&(Math.abs(t.gamma)>1||Math.abs(t.beta)>1)&&($e=!0,qe=Math.max(-1,Math.min(1,(t.gamma||0)/45)),Xe=Math.max(-1,Math.min(1,(t.beta||0)/45)))})}function Tt(){if(("ontouchstart"in window||navigator.maxTouchPoints>0)&&window.DeviceOrientationEvent)if(typeof DeviceOrientationEvent.requestPermission=="function"){let e=()=>{DeviceOrientationEvent.requestPermission().then(o=>{o==="granted"&&ke()}).catch(console.error)};C(document.body,"click",e,{once:!0})}else ke()}function Ke(){let t=window.innerHeight,e=window.innerWidth;g.forEach(o=>{if(P&&!o.isInViewportMargin){o.isRenderable=!1;return}let i=o.container.getBoundingClientRect();o.cachedRect=i,o.isRenderable=i.bottom>-M&&i.top<t+M&&i.right>-M&&i.left<e+M}),H=!1}function Ct(){"IntersectionObserver"in window?(P=new IntersectionObserver(t=>{t.forEach(e=>{let o=oe.get(e.target);o&&(o.isInViewportMargin=e.isIntersecting,e.isIntersecting?o.cachedRect=e.boundingClientRect:o.isRenderable=!1)}),H=!0},{root:null,rootMargin:`${M}px 0px ${M}px 0px`,threshold:0}),g.forEach(t=>P?.observe(t.container))):g.forEach(t=>{t.isInViewportMargin=!0}),"ResizeObserver"in window&&(I=new ResizeObserver(t=>{t.forEach(e=>{let o=oe.get(e.target);o&&(o.cachedRect=o.container.getBoundingClientRect())}),H=!0}),g.forEach(t=>I?.observe(t.container)))}function ge(){Y||U!==null||document.hidden||(ue=Date.now(),U=requestAnimationFrame(Ze))}function B(){U!==null&&(cancelAnimationFrame(U),U=null)}function Ze(){if(Y||document.hidden){B();return}let t=Date.now(),e=(t-ue)/1e3;ue=t;let o=15,i=Math.abs(f)*.1,r=o+i;f>0?f=Math.max(0,f-r*e):f<0&&(f=Math.min(0,f+r*e)),y+=f*e,y>1e6&&(y-=1e6),y<-1e6&&(y+=1e6),Math.abs(f)>.01?U=requestAnimationFrame(Ze):(f=0,B())}function Qe(){if(Y||(J=requestAnimationFrame(Qe),!he||!v||g.length===0))return;let t=Date.now(),e=t<St||t-ee<Ae;(H||e)&&Ke();let o=performance.now()/1e3,i=[];g.forEach(a=>{a.isRenderable&&a.cachedRect?i.push({thumb:a,rect:a.cachedRect}):a.setVisible(!1)}),i.forEach(({thumb:a,rect:s})=>{a.setVisible(!0),a.update(y,o,s,me,pe,$e,qe,Xe)}),v&&v.renderer.render(v.scene,v.camera);let r=performance.now();r-Ge>=K&&(w("global-speed",f.toFixed(1)),w("render-count",String(i.length)),Ge=r)}function Je(){if(H=!0,te){F=window.pageYOffset||document.documentElement.scrollTop,ee=Date.now();return}let t=window.pageYOffset||document.documentElement.scrollTop,e=Date.now(),o=(e-ee)/1e3;if(o>0){let i=(t-F)/o,a=Math.max(-30,Math.min(30,i/15));f+=(a-f)*Pe}F=t,ee=e,Math.abs(f)>.01&&ge()}function Mt(){H=!0,v&&v.resize()}function w(t,e){let o=document.getElementById(t);o&&(o.textContent=e)}function We(){Y||(Y=!0,B(),J!==null&&(cancelAnimationFrame(J),J=null),D!==null&&(clearTimeout(D),D=null),I&&(I.disconnect(),I=null),P&&(P.disconnect(),P=null),N&&(fe.removeEventListener("change",N),N=null),xt(),g.forEach(t=>t.destroy()),g=[],oe.clear(),R.forEach(t=>t.dispose()),R=[],Object.values(x).forEach(t=>{t.rgbTexture.dispose(),t.depthTexture.dispose()}),Object.keys(x).forEach(t=>{delete x[t]}),le(),v&&(v.dispose(),v=null))}async function Rt(t={}){let{canvasId:e="shared-depth-canvas",spriteBasePath:o=j,resolution:i=T,config:r}=t;if(S=Z(r),Be(te),C(window,"pagehide",We),C(window,"beforeunload",We),!se()){he=!1,document.body.classList.add("no-webgl"),w("global-speed","n/a"),w("render-count","0"),w("gl-context-count","0"),console.warn("WebGL is unavailable. Falling back to static thumbnail containers.");return}try{let l=document.getElementById(e);if(!l)throw new Error(`Canvas element #${e} not found`);v=new z(l)}catch(l){he=!1,document.body.classList.add("no-webgl"),w("global-speed","n/a"),w("render-count","0"),w("gl-context-count","0"),console.error("Failed to initialize shared WebGL renderer:",l);return}let a=document.querySelectorAll(".project-item[data-sprite]"),s=[...new Set([...a].map(l=>l.dataset.sprite))];console.log(`Loading ${s.length} sprite sets...`);let d=s.map(async l=>{let n=await je(l,o);n&&(x[l]=n)});await Promise.all(d),console.log(`Loaded ${Object.keys(x).length} sprite sets`),a.forEach(l=>{let n=l.querySelector(".thumbnail-container"),u=l.dataset.sprite;if(!n||!u||!x[u]){console.warn(`Sprite set not loaded: ${u}`);return}let h=new V(n,u,v,x,S,i,te);h.createPointCloud(),g.push(h),oe.set(n,h)}),console.log(`Created ${g.length} point cloud thumbnails`),w("gl-context-count","1"),wt(),Tt(),Ct(),Ke(),C(window,"resize",Mt),C(window,"scroll",Je,{passive:!0}),N=l=>{Be(l.matches)},fe.addEventListener("change",N),C(document,"visibilitychange",()=>{document.hidden?B():Math.abs(f)>.01&&ge()}),F=window.pageYOffset||document.documentElement.scrollTop,Qe()}async function yt(t={}){let{spriteBasePath:e=j,resolution:o=T,config:i}=t,r=Q(i),a=document.querySelectorAll(".project-item[data-sprite]"),s=[...new Set([...a].map(n=>n.dataset.sprite))];console.log(`Loading ${s.length} sprite sets...`);let d=s.map(async n=>{let u=await je(n,e);u&&(x[n]=u)});await Promise.all(d),console.log(`Loaded ${Object.keys(x).length} sprite sets`),a.forEach(n=>{let u=n.querySelector(".depth-canvas"),h=n.dataset.sprite;if(!u||!h||!x[h]){console.warn(`Sprite set not loaded: ${h}`);return}let E=new O(u,h,x,r,o);E.createMesh(),R.push(E)}),console.log(`Created ${R.length} depth mesh thumbnails`),window.addEventListener("resize",()=>{R.forEach(n=>n.updateSize())}),window.addEventListener("scroll",Je),document.addEventListener("visibilitychange",()=>{document.hidden?B():Math.abs(f)>.01&&ge()}),F=window.pageYOffset||document.documentElement.scrollTop;function l(){requestAnimationFrame(l),R.length!==0&&(R.forEach(n=>n.update(y)),w("global-speed",f.toFixed(1)))}l()}function Dt(){return{...S}}function At(t){S={...S,...t},g.forEach(e=>e.updateConfig(S))}function et(){g.forEach(t=>t.rebuildPointCloud())}function Lt(){D!==null&&clearTimeout(D),D=setTimeout(()=>{D=null,et()},De)}typeof window<"u"&&(window.ThreeVisualization={initPointCloud:Rt,initDepthMesh:yt,getConfig:Dt,updateConfig:At,rebuildPointClouds:et,scheduleRebuild:Lt,PointShape:X,ColorMode:$,parsePointShape:He,parseColorMode:_e,toCamelCase:Ue});})();
//# sourceMappingURL=three-bundle.js.map
